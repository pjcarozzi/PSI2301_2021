[["index.html", "Apuntes PSI2301 Presentacion", " Apuntes PSI2301 Profesor: Roberto González (rgonzale@uc.cl). Ayudantes: Josefina Bao (josefina.bao@uc.cl); Javiera Maechtig (jmaechtig@uc.cl); Pia Carozzi (pjcarozzi@uc.cl); Samuel Casale (scasale@uc.cl). Creado: 2021-03. Actualizado: 2021-03-19 Presentacion Este documento reune tutoriales y recursos producidos para el curso Metodos de Investigacion Cuantitativa de la Escuela de Psicologia de la Pontificia Universidad Catolica de Chile. Para reproducir el codigo presentado en este documento, se necesita una version reciente de R y RStudio, instalar los paquetes especificados en cada guia y tenerlos actualizados. Para compilar este documento localmente: Clona o descarga el repositorio asociado y descomprime el archivo .zip. Abre R Studio. Instalar el paquete bookdown Localiza la carpeta del repositorio. Abre el archivo index.Rmd y haz click en Build Book en la pestaña Build. Alternativamente, ejecuta: install.packages(&#39;bookdown&#39;) # instalar bookdown bookdown::render_book(&quot;index.Rmd&quot;) # para compilar browseURL(&quot;_book/index.html&quot;) # para ver Apuntes PSI2301, Escuela de Psicologia PUC esta bajo una licencia de Creative Commons Atribución-NoComercial-CompartirIgual 4.0 Internacional (CC BY-NC-SA 4.0) "],["intro.html", "1 Introduccion a R 1.1 R y R Studio 1.2 Operadores basicos en R 1.3 Asignacion de variables 1.4 Tipos de datos 1.5 Vectores 1.6 Matrices 1.7 Factores 1.8 Dataframes 1.9 Listas", " 1 Introduccion a R 1.1 R y R Studio 1.1.1 El entorno de R R es un entorno para la computacion estadistica, una suite integrada de software para manipulacion, calculo y visualizacion grafica de datos, que reune una gran cantidad de funcionalidades en un sistema coherente. El entorno de R combina: Una manejo de datos y funcionalidades de almacenamiento. Una suite de operadores para el calculo con distintos tipos de formaciones (arrays). Una coleccion amplia, coherente e integrada de herramientas intermedias para el analisis de datos. Funcionalidades graficas para el analisis y visualizacion de datos. Un lenguaje de programacion bien desarrollado, simple y efectivo. R es ampliamente usado por las comunidad de estadistica y desarrollo de software estadistico y se ha convertido en la lengua franca en el mundo del data science y analytics. Como lenguaje de programacion, se basa en el lenguaje S, que se convirtio en S-Plus una implementacion comercial, pero a diferencia de este R es esta disponible como un software libre bajo los terminos de la Free Software Foundations GNU General Public License en su forma de codigo fuente. Gracias a esto, se ha desarrollado una comunidad de pares amplia y en crecimiento en torno al desarrollo de nuevas funcionalidades. R corre en los sistemas operativos Windows y Mac y tambien en una amplia variedad de plataformas UNIX (incluyendo Linux y FreeBSD). 1.1.2 RStudio RStudio es un Entorno de Desarrollo Integrado (IDE) que entrega herramientas que facilitan el uso de R, mejorando la habilidad del usuario de interactuar con R y mantener un espacio de trabajo organizado. RStudio es una muy buena alternativa a trabajar con R directamente desde la terminal. RStudio: Incluye una interfaz de usuario grafica (GUI) que permite al usuario interactuar a traves de iconos, no solo una interfaz de linea de comandos. Tiene una amplia de funcionalidades adicionales a la GUI de R base: Ademas de una consola de comandos, un editor con subrayado de sintaxis que permite la ejecucion de codigo directa, herramientas para graficar, historial, debugging y administracion del espacio de trabajo, entre otros. Es open-source y gratis para su uso academico. Al igual que R, corre en multiples plataformas. 1.1.3 Instalando R y R Studio Para usar R, instalaremos dos paquetes de software distintos: R y R Studio. R es el software basico que contiene la programacion del entorno R. R Studio es la IDE que usaremos para interactuar con R. No es necesario contar con R Studio para usar R, pero es esencial que descarguemos e instalemos R antes de empezar a usar R Studio. Para instalar R, vamos a uno de los siguientes links y seguimos las instrucciones. Windows: http://cran.r-project.org/bin/windows/base/ Mac: http://cran.r-project.org/bin/macosx/ Una vez que hemos instalado R en nuestro computador, podemos abrirlo. Veremos una pantalla como la siguiente. Interfaz de R Descarguemos R Studio, que sera el programa que utilizaremos en lo sucesivo en nuestra programacion de R. Para descargar e instalar R Studio, vamos a http://www.rstudio.com/products/rstudio/download/ y seguimos las instrucciones. Abramos R Studio para explorar su interfaz. 1.1.4 La interfaz de R Studio (y algunos conceptos basicos) La interfaz de R Studio tiene cuatro paneles principales: Console: Donde podemos tipear los comandos y donde aparecen los resultados u output. La consola es lo unico que veriamos si corrieramos R desde su GUI original. Script editor: Donde podemos escribir nuestro codigo y guardarlos en un archivo. Tambien podemos correr nuestro codigo a ejecutar en la consola directamente desde aqui. Environment/History: Son dos pestañas. Environment muestra todos los objetos activos e History va registrando todos los comandos que han sido ejecutados. Files/Plots/Packages/Help: Estas pestañas muestran informacion util que veremos en detalle a continuacion. Interfaz de R Studio Consola La ventana console es el lugar donde R espera recibir las instrucciones que escribimos en el lenguaje R, o comandos, y muestra los resultados de dichas instrucciones. En esta guia, los comandos en R que utilicemos apareceran en una caja gris como la siguiente: c(1,2,3,4,5,6,7,8,9,10,11,12) La command prompt o linea de comandos, ubicada en la parte baja de la consola, tiene diferentes estados: Cuando R esta listo para aceptar un comando, la linea de comandos muestra un &gt;. Si escribimos el codigo anterior en la linea de comandos y presionamos Enter, el codigo sera ejecutado y producira un output o resultado en la misma consola. En este caso el resultado sera: ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 Tras su ejecucion, la consola muestra los resultados,limpia la linea y vuelve a mostrar un &gt;, avisando que ya puede recibir un nuevo comando. Cuando la consola esta esperando que se ingresen mas datos muestra un +. Esto indica que el comando entregado no esta completo y aun no puede ser ejecutado. Probemos escribiendo lo siguiente: c(1,2,3,4,5,6,7,8,9,10,11,12 La consola no nos devuelve un resultado sino un +. En este caso es porque no hemos cerrado el parentesis. Si lo tipeamos y presionamos Enter obtendremos el resultado anterior. Si no queremos continuar con la ejecucion de un comando incompleto, hacemos click situando el cursor en la linea de comandos y presionamos esc para salir del comando sin correrlo. R volvera a mostrar un un &gt;. Script editor Los comandos que escribimos directamente en la consola no quedan registrados y se eliminan una vez se cierra la sesion. Por eso es recomendable ingresar los comandos en el editor de scripts, lo que nos permite guardar el codigo en un archivo .R de texto plano. Otra ventaja de usar un script es que nos evita tener que ejecutar los comandos de forma inmediata y secuencial, lo que nos permite ir modificando el codigo a nuestro ritmo. El editor de scripts de R Studio nos permite mandar lineas de codigo a la consola para su ejecucion. Para hacerlo, destacamos el texto del codigo que queremos correr y hacemos click en el boton Run, situado en la parte superior derecha del editor de scripts. Alternativamente, podemos ejecutar el texto destacado presionando de manera simultanea Ctrl+Enter en Windows o cmd + Enter en Mac. R interpreta todo lo que es escrito en la consola o en el script como comandos. Para evitar que una linea de texto sea ejecutada como tal, usamos el signo # al comienzo de la linea o, dentro de una linea, desde la posicion en la que queremos que deje de ejecutar. Todo el texto que siga al signo # sera ignorado a la hora de ejecutar el codigo. # Esta linea completa no se ejecutara. mean(1:12) # Esta linea contiene un comando que sera ejecutado y una parte que no sera ejecutada ## [1] 6.5 Esta funcionalidad es muy util, porque permite comentar y documentar el codigo que escribimos en el mismo script. De esta manera, no solo disponemos de un registro completo de los analisis que realizamos, que podremos volver a correr si lo necesitamos. Tambien podemos mostrarle a otros como lo hicimos, porque lo hicimos y que ellos puedan ejecutar nuestros analisis por su cuenta. En investigacion cuantitativa, esto se relaciona con uno de los mayores principios del metodo cientifico: la reproducibilidad o capacidad de obtener los mismos resultados de un estudio si este es replicado usando los mismos datos y metodologias. Cuando la investigacion se apoya en metodos computacionales, esto implica que los set de datos y procesos de analisis deben ser documentados rigurosamente tal que una tercera parte pueda ejecutar el codigo y, disponiendo de los datos, obtener identicos resultados. Hoy esto es considerado una buena practica y cada vez mas un estandar minimo en la publicacion cientifica. Environment e History La pestaña environment muestra los nombres de los objetos de datos que han sido definidos en la sesion actual de R. Un objeto es una cosa, un numero, un set de datos, estadisticos o tests. Los objetos tienen distintas formas, tamaños y atributos: Hay objetos simples que representan numeros, como los vectores; objetos un poco mas complejos que tienen mas de una dimension, como los dataframes o las matrices; y objetos mucho mas complejos, como los producidos a partir de test de hipotesis o regresiones, que contienen muchos tipos distintos de informacion estadistica. Mas adelante vamos a ahondar en la asignacion de objetos y los tipos de objetos en R y sus caracteristicas. Por ahora solo quedemonos con la idea de que en R hay distintos tipos de objetos. Veamos un ejemplo. Ejecutando el siguiente codigo crearemos distintos objetos: mi_vector &lt;- c(1:12) mi_matriz &lt;- matrix(1:12, byrow = T, nrow = 3) mi_df &lt;- iris mi_lista &lt;- list(mi_vector,mi_matriz,mi_df) tu_vector &lt;- c(1:120) tu_matriz &lt;- matrix(1:21, byrow = T, nrow = 3) tu_df &lt;- mtcars Una vez definidos, los objetos aparecen en la pestaña environment en secciones dependiendo del tipo de objeto en cuestion. En este ejemplo, encontramos nuestros objetos en Data y Values. Tambien se muestra informacion basica de cada uno, sus dimensiones (ej. la cantidad de elementos que contienen, el numero de filas y columnas, observaciones y variables) y el tipo de dato que contienen. Veamos brevemente algunas utiles para explorar nuestro espacio de trabajo. Supongamos hemos cargado o creado muchos objetos y queremos revisarlos rapidamente. La funcion ls() muestra los nombres de todos los objetos que tenemos actualmente en el espacio de trabajo. ls() ## [1] &quot;mi_df&quot; &quot;mi_lista&quot; &quot;mi_matriz&quot; &quot;mi_vector&quot; &quot;tu_df&quot; &quot;tu_matriz&quot; ## [7] &quot;tu_vector&quot; Para eliminar objetos del espacio de trabajo tenemos varias opciones. Podriamos usar el boton en la parte superior de la pestaña environment que muestra el icono de una escoba y eliminar todos los objetos. Si lo presionamos aparece una ventana emergente que pide confirmacion. Otra alternativa, que nos permite mayor control, es eliminar objetos utilizando la funcion rm(). Podemos indicar los nombres de los objetos a eliminar uno a uno: rm(mi_vector,tu_vector) O eliminarlos siguiento un patron de busqueda. En este ejemplo, eliminamos todos los objetos que terminan en \"_df\" rm(list = ls(pattern = &quot;_df$&quot;)) Tambien podemos eliminar todos los elementos usando el siguiente codigo. rm(list=ls(all=TRUE)) La pestaña History en este panel simplemente muestra un historial de todos los codigos que han sido ejecutados previamente. Funciones y librerias Antes de seguir revisando la interfaz de R Studio, clarifiquemos un par de cosas basicas. En la medida en que trabajemos mas con R, vamos a notar que casi todo en R es un objeto o una funcion. Ya hemos hablado introductoriamente de los objetos y mencionado algunas funciones, pero ¿que es una funcion? Las funciones son modulos de codigo autocontenidos que cumplen con una tarea especifica. En terminos practicos, una funcion es un procedimiento que toma uno o mas objetos como inputs, hace algo con esos objetos y luego devuelve otro objeto como resultado. Una funcion basica tiene tres partes: nombre, parentesis y argumentos. Se veria de la siguiente manera: nombre_de_la_funcion(argumento) No todas las funciones incluyen argumentos (como vimos con la funcion ls()), no obstante, la mayoria de las funciones si los toman. Los argumentos de una funcion pueden incluir: El objeto fisico que sera procesado. Opciones, especificaciones que alteran como opera la funcion. Si no especificamos un argumento requerido al llamar una funcion, recibiremos un error o la funcion va a operar con los valores que trae por defecto. Los default de una funcion representan valores estandar que el o la autora de la funcion ha especificado como lo suficientemente buenos en casos estandar. Siempre es bueno tener claridad de cuales son los defaults de las funciones que usamos y cuales son las opciones que estas permiten, de manera de que, si necesitamos un procesamiento especifico, podamos indicarlo. Veamos un ejemplo basico. La funcion mean() toma datos numericos como argumento (esto va entre parentesis), calcula la media aritmetica de esos datos y luego devuelve un numero unico como resultado. Primero intentemos correr la funcion mean() sin argumentos. mean() &gt; mean() Error in mean.default() : argument &quot;x&quot; is missing, with no default Esto resulta en error, porque la funcion mean() requiere que especifiquemos un objeto (un vector) numerico para operar. En el codigo siguiente, creamos un objeto con numeros y lo ingresamos al interior de los parentesis de la funcion mean(). mi_vector &lt;- c(-500,1,6,5,7,10,9,4,2,8,3,10000) mean(mi_vector) ## [1] 796.25 Esta vez si obtenemos un resultado, el promedio de los numeros que especificamos. Modifiquemos nuestro argumento mi_vector para que incluya casos perdidos (indicados con NA, not available). Los casos perdidos son algo con lo que de seguro nos vamos a enfrentar al analizar datos en el futuro. Corremos el codigo para hacer efectivos nuestros cambios. mi_vector &lt;- c(-500,1,6,5,7,NA,10,9,4,2,8,NA,3,10000) Ahora intentemos correr la funcion mean() usando mi_vector como argumento. mean(mi_vector) ## [1] NA Esta vez obtenemos NA como resultado, porque, bajo las opciones default, mean() no nos puede entregar un promedio. Le faltan datos. Aprovechemos de introducir los archivos de ayuda de R. El operador de ayuda ? nos da acceso a la documentacion de R para funciones, datasets y otros objetos. Para leer la documentacion de la funcion mean(), tipeamos ?mean en la consola o en el script y ejecutamos. ?mean La documentacion aparecera automaticamente en la pestaña Help. Si nos fijamos en el subtitulo Usage, leemos: ## Default S3 method: mean(x, trim = 0, na.rm = FALSE, ...) Lo que indica que que mean() usa tres argumentos. Uno de ellos es x, nuestro objeto numerico, pero posee dos defaults trim = 0 y na.rm = FALSE. Mas abajo indica que la opcion na.rm acepta un argumento logico que indica si los valores NA deben ser excluidos de los calculos. Veamos que sucede si corremos mean() indicando na.rm = TRUE. mean(mi_vector, na.rm=TRUE) ## [1] 796.25 Esta vez si nos entrega un resultado. Probemos cambiando el otro argumento que viene por default. trim sirve para calcular medias truncadas, un procedimiento especifico que excluye parte de los valores ingresados del calculo de la media. Por lo general, usamos todos los numeros para calcular la media, por lo que se entiende que la opcion por default sea trim = 0. trim acepta argumentos numericos que representan la fraccion de las observaciones que deben ser excluidas del calculo de la media a cada extremo de x. Supongamos que queremos una media truncada de nuestra secuencia de numeros, que excluya los valores outliers -500 y 10000. Nos quedariamos solo con una secuencia de numeros del 1 al 10 (sabemos que el promedio de los numeros del 1 al 10 es 5.5). Usemos mean() y especificamos que se trunque el 0.1 de los valores y recalculamos. mean(mi_vector, na.rm=T, trim=0.1) ## [1] 5.5 Otra opcion. Cuando no necesitamos leer toda la documentacion asociada a una funcion porque ya sabemos como trabaja, pero conocemos exactamente cuales son sus argumentos, podemos usar la funcion args(). Veamos otro ejemplo. La funcion round() nos permite redondear valores que tienen decimales. Sabemos que \\(\\pi \\approx 3.1415926535\\). round(3.1415926535) ## [1] 3 Por default, round() trunco \\(\\pi\\), nos devuelve solo la parte entera, lo que puede no ser tan util. Revisemos los argumentos de round() con la funcion args(). args(round) ## function (x, digits = 0) ## NULL El output nos muestra el argumento digits y que por default digits = 0. Especifiquemos que queremos redondear a cuatro digitos: round(3.1415926535, digits=4) ## [1] 3.1416 A veces solo necesitamos ejemplos del funcionamiento de una funcion. Por ejemplo, la funcion sum() devuelve la suma de los valores presentes en sus argumentos. Veamos algunos ejemplos de sum(). example(sum) ## ## sum&gt; ## Pass a vector to sum, and it will add the elements together. ## sum&gt; sum(1:5) ## [1] 15 ## ## sum&gt; ## Pass several numbers to sum, and it also adds the elements. ## sum&gt; sum(1, 2, 3, 4, 5) ## [1] 15 ## ## sum&gt; ## In fact, you can pass vectors into several arguments, and everything gets added. ## sum&gt; sum(1:2, 3:5) ## [1] 15 ## ## sum&gt; ## If there are missing values, the sum is unknown, i.e., also missing, .... ## sum&gt; sum(1:5, NA) ## [1] NA ## ## sum&gt; ## ... unless we exclude missing values explicitly: ## sum&gt; sum(1:5, NA, na.rm = TRUE) ## [1] 15 El entorno base de R trae implementadas internamente funciones basicas como mean(), round() o sum(), pero muchas otras han sido desarrolladas y forman parte de packages o libraries. Los packages o paquetes son colecciones de funciones de R, datos y codigos compilados en un formato bien definido, creado para agregar una funcionalidad especifica. Existe un set de paquetes standard o recomendados de R que son considerados parte del codigo fuente de R y estan automaticamente disponibles como parte de la instalacion de R. Estos paquetes base contienen funciones basicas que permiten que R trabaje y el desarrollo de analisis estadisticos y graficos (como las que hemos visto hasta ahora). Los directorios en R donde los paquetes son almacenados se llaman libraries o librerias. A veces, los terminos paquete y libreria se usan como sinonimos. En la medida en que usemos R para realizar tareas mas especificas, nos vamos a dar cuenta de que existen muchisimos paquetes y que estos ofrecen una gran variedad de funcionalidades. Para usar paquetes adicionales a los standard necesitamos instalarlos desde CRAN. En CRAN encontraremos, ademas las ultimas versiones de R, un repositorio con miles de paquetes de R contribuidos por los usuarios. Para instalarlos utilizamos la funcion install.packages(), que va a descargar el codigo fuente del paquete desde los mirrors de CRAN, e instalara el paquete y sus dependencias localmente en nuestros computadores. Como ejemplo, instalemos el paquete de visualizacion de datos ggplot2. Corremos el siguiente codigo. En la consola indicara el tamaño del paquete, el avance de la instalacion y la ruta donde quedo instalado. install.packages(&quot;ggplot2&quot;) Una vez hemos instalado el paquete localmente, necesitamos cargar la libreria en la sesion actual de R. Las funciones especificas del paquete estaran disponibles para ser usadas tal y como hemos estado llamando las funciones que revisamos hasta ahora, pero solo una vez la libreria sea cargada. Para cargar una libreria usamos la funcion library(). library(ggplot2) Algo importante a mencionar es que solo necesitamos instalar los paquetes una vez en nuestros computadores. No obstante, para usar el paquete, necesitamos cargar su libreria cada vez que iniciamos una nueva sesion en R. Una analogia util es pensar en una ampolleta y encender la luz. Instalamos la ampolleta una vez, install.packages(\"luz\"), pero tenemos que apretar el interruptor cada vez que queremos encender la luz, library(luz) (sin comillas!). Podemos chequear que librerias estan cargadas en el entorno usando la funcion sessionInfo(). sessionInfo() ## R version 4.0.4 (2021-02-15) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 19043) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=English_United States.1252 ## [2] LC_CTYPE=English_United States.1252 ## [3] LC_MONETARY=English_United States.1252 ## [4] LC_NUMERIC=C ## [5] LC_TIME=English_United States.1252 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] ggplot2_3.3.3 ## ## loaded via a namespace (and not attached): ## [1] rstudioapi_0.13 knitr_1.31 magrittr_2.0.1 tidyselect_1.1.0 ## [5] munsell_0.5.0 colorspace_2.0-0 R6_2.5.0 rlang_0.4.10 ## [9] fansi_0.4.2 dplyr_1.0.5 stringr_1.4.0 tools_4.0.4 ## [13] grid_4.0.4 gtable_0.3.0 xfun_0.22 utf8_1.1.4 ## [17] withr_2.4.1 htmltools_0.5.1.1 ellipsis_0.3.1 yaml_2.2.1 ## [21] digest_0.6.27 tibble_3.1.0 lifecycle_1.0.0 crayon_1.4.1 ## [25] bookdown_0.21 purrr_0.3.4 vctrs_0.3.6 glue_1.4.2 ## [29] evaluate_0.14 rmarkdown_2.7 stringi_1.5.3 compiler_4.0.4 ## [33] pillar_1.5.1 generics_0.1.0 scales_1.1.1 pkgconfig_2.0.3 En este caso, varios paquetes se cargaron necesarios para usar las funciones de ggplot2 se cargaron automaticamente junto a ggplot2. Files / Plots / Packages / Help Ahora podemos volver a nuestra revision de la interfaz de R Studio. La pestaña Packages, como su nombre lo indica, nos muestra listados todos los paquetes que estan instalados localmente. Las librerias que estan cargadas en la sesion actual aparecen marcadas con un check. Si hacemos click en el nombre del paquete accedemos a la documentacion: su descripcion, guias de usuario y las paginas de ayuda para cada una de sus funciones. Esto nos lleva a la pestaña Help, el menu de ayuda de R. Podemos acceder a la misma informacion que cuando usamos el operador ? si tipeamos el nombre de una funcion en la caja de busqueda que esta en la parte superior de la pestaña. El panel Files da acceso a los directorios en el disco duro. Una de las caracteristicas utiles del panel archivos es que se puede usar para declarar el directorio de trabajo, de lo que hablaremos en la proxima seccion. Finalmente la pestaña Plots muestra los graficos que hemos generado en la sesion. Los botones permiten abrir los graficos en una ventana separada, exportarlos y guardarlos (aunque esto tambien se puede hacer usando codigo). Veamos brevemente como funciona, tendremos una sesion dedicada a la visualizacion de datos mas adelante. Cargamos en nuestro espacio de trabajo la base de datos iris, que viene incluida como ejemplo con los paquetes standard de R. Se trata de una base de datos que contiene medidas en centimetros de petalos y sepalos de 50 flores de cada una de las tres especies de iris. iris_dt &lt;- iris Con el codigo a continuacion, generamos un histograma del largo de los petalos. hist(x = iris_dt$Petal.Length, ylim = c(0, 50), main = &quot;Largo del Petalo&quot;, xlab = &quot;Largo (cm)&quot;, ylab = &quot;Frecuencia&quot;, col = &quot;skyblue&quot;, border = &quot;white&quot;) Figura 1.1: El panel Plot contiene los graficos, como este histograma de la distribucion del largo del sepalo para la muestra de flores de la base de datos Iris. 1.1.5 Administrando, importando y guardando archivos y datos. Working directory Para ayudarnos a mantener nuestros archivos ordenados, R usa working directories o directorios de trabajo. Un directorio de trabajo es una ruta local que indica la localizacion por defecto de los archivos que cargaremos o guardaremos en una sesion de R. La carpeta a la que refiere dicha ruta puede estar en cualquier lado, pero es recomendable asociar una carpeta para cada proyecto de analisis especifico de manera de mantener en un solo lugar sus archivos. Si, por ejemplo, pedimos a R que cargue determinado archivo, R supone en primera instancia que este se encuentra en el directorio de trabajo, lo que nos ahorra tener que especificar la ruta completa. Solo podemos tener un directorio de trabajo activo por sesion. Para ver cual es el directorio de trabajo actual, usamos la funcion getwd() getwd() ## [1] &quot;C:/Users/pjcar/Dropbox/PSI2301_2021&quot; Como podemos ver, cuando ejecuto la funcion, R me indica que el directorio de trabajo actual es una carpeta llamada bd_apuntes. Esto implica que cuando leo nuevos archivos en R, R asume que se encuentran en esta carpeta. Si queremos cambiar el directorio de trabajo, usamos la funcion setwd(). Por ejemplo, me gustaria cambiar mi directorio de trabajo a una carpeta en mi Escritorio llamada ayud_1. setwd(&quot;C:/Users/pjcar/Desktop/ayud_1&quot;) Comprobemos si realizo el cambio getwd() ## [1] &quot;C:/Users/pjcar/Desktop/ayud_1&quot; .RData La mejor manera de almacenar objetos de R son los archivos .RData, especificos de R. Los archivos .RData pueden guardar muchos objetos en un unico archivo. Para guardar un archivo .RData, usamos la funcion save(). Sus argumentos son los objetos que queremos almacenar en el archivo y la opcion file, donde indicamos el nombre del archivo. Guardemos uno de los objetos que tenemos en nuestro espacio de trabajo. save(iris_dt, file=&quot;mi_objeto.RData&quot;) Una vez que ejecutamos la funcion, podremos ver mi_objeto.RData en el directorio de trabajo. Si tuvieramos muchos objetos y no queremos tipear cada uno de sus nombres, podemos usar la funcion save.image(), que guardara todos los objetos que estan actualmente en el espacio de trabajo. save.image(file=&quot;mis_objetos.RData&quot;) Borremos nuestos objetos con la funcion rm() que ya revisamos. rm(list=ls(all=TRUE)) Para cargar un archivo .RData, importando los objetos que contiene, usamos la funcion load(). load(file=&quot;mis_objetos.RData&quot;) Exportando e importando .csv R permite exportar datos a archivos que pueden ser leidos por otros programas. CSV es un formato de archivo simple y mas o menos universal usado para guardar datos en dos dimensiones (ej. bases de datos). Para guardar un objeto de estas caracteristicas, usamos la funcion write.csv(). Sus argumentos basicos son el objeto a ser guardado y file, donde indicamos el nombre del archivo. Por default, write.csv() crea una primera columna en la que ennumera las filas. Esto no suele ser muy util y podemos indicar que no lo haga usando el argumento row.names=FALSE. write.csv(iris_dt,file=&quot;iris.csv&quot;,row.names=FALSE) Para importar un archivo .csv, utilizamos la funcion read.csv(). Sus argumentos basicos son dos: file, la ruta donde se encuentra el archivo y, si se trata de una base de datos, header = TRUE, lo que indica a R que la primera fila contiene un encabezado (los nombres de las variables). Además, para cargar el archivo a nuestro espacio de trabajo debemos asignarle un nombre y crear el objeto. Carguemos el archivo iris.csv en nuestro espacio de trabajo, asignandolo al objeto iris_nuevo iris_nuevo &lt;- read.csv(file=&quot;iris.csv&quot;, header=TRUE) 1.2 Operadores basicos en R 1.2.1 Operadores aritmeticos En su forma mas basica, R puede ser usado como una calculadora. Los operadores aritmeticos basicos son los convencionales: Suma: + Resta: - Multiplicacion: * Division: / Potencia: ^ Modulo: %%. El modulo calcula el resto o diferencia de la division entre un dividendo y un divisor (ej. 5 mod 2 da 1, porque 2 * 2 es 4 y el resto o diferencia es 1) Division de intergers: %/%. La division de intergers calcula la division entre un dividendo y un divisor ignorando la parte fraccional del resultado (ej. 5/2 es 2.5, pero la division de integers 5\\2 es 2) Ejemplos: 4 + 7 ## [1] 11 9 - 5 ## [1] 4 7 * 8 ## [1] 56 (5 + 5) / 2 ## [1] 5 9 ^ 3 ## [1] 729 28 %% 6 ## [1] 4 28 / 6 ## [1] 4.666667 28 %/% 6 ## [1] 4 1.2.2 Operadores logicos Los operadores logicos en R son los siguientes: &lt; : menor que. &gt; : mayor que. &lt;=: menor o igual que. &gt;=: mayor o igual que. ==: igual. !=: no igual. ! : no (ej. !a evalua si algo no es a) | : o (ej. a|b evalua si algo es a O b) &amp; : y (ej. a&amp;b evalua si algo es a Y b) Veamos algunos ejemplos: 5&lt;2 ## [1] FALSE 5&gt;2 ## [1] TRUE 7==(3+4) ## [1] TRUE 7!=(4+4) ## [1] TRUE Usemos mas de un numero. En R el operador : crea una serie de numeros en secuencia entre el primer numero indicado y el segundo numero, incluyendolos. 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 Evaluemos que numeros en la secuencia del 1 al 10 son mayores o iguales a 8 1:10&gt;=8 ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE TRUE Ahora cuales numeros de dicha secuencias son mayores o iguales a 8 o menores a 5 (1:10&gt;=8) | (1:10&lt;4) ## [1] TRUE TRUE TRUE FALSE FALSE FALSE FALSE TRUE TRUE TRUE Finalmente, cuales numeros de dicha secuencias son mayores o iguales que 3 y son pares (aprovechemos de usar modulo, si un numero x es par, x es divisible por 2, por lo tanto, x mod 2 es 0) (1:10&gt;=3) &amp; (1:10%%2==0) ## [1] FALSE FALSE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE 1.3 Asignacion de variables Un concepto basico en la programacion estadistica es el concepto de variable. Una variable permite guardar un valor o un objeto en R. Despues de guardarlo o asignarlo, podemos usar el nombre de la variable para acceder al valor o al objeto que esta almacenado en la variable. Asignemos el valor 7 a una variable llamada mi_variable. Para hacerlo, usamos el operador de asignacion &lt;-. El shorcut para el operador de asignacion es Alt + - (Windows) o Option + - (Mac). mi_variable &lt;- 7 Podemos ver que la variable mi_variable aparece como valor en la ventana environment de RStudio. Para imprimir el valor almacenado en mi_variable tenemos que escribir su nombre y ejecutar. mi_variable ## [1] 7 Practiquemos la asignacion de variables y operaciones basicas. Creamos dos variables: manzanas, a la que le asignamos el valor 54 y peras, a la que le asignamos el valor 22. manzanas &lt;- 54 peras &lt;- 22 Sumemos las variables manzanas y peras, y asignamos el resultado a una variable llamada frutas. Imprimimos el resultado frutas &lt;- manzanas + peras frutas ## [1] 76 1.4 Tipos de datos Probemos asignando a una variable llamada naranjas que contenga el valor de caracteres \"nueve\". En R los valores de caracteres son identificados poniendolos entre comillas. Si no se usaran comillas, las palabras son interpretadas como si fueran nombres de objetos en el environment naranjas &lt;- nueve Lo que arroja el siguiente error de evaluacion si el objeto no existe: Error: object &#39;nueve&#39; not found Si el objeto existiera, se copia bajo el nombre asignado. naranjas &lt;- manzanas naranjas ## [1] 54 manzanas ## [1] 54 Volvamos a crear la variable naranjas, esta vez como habiamos dicho, asignada al valor \"nueve\" y la mprimimos. naranjas &lt;- &quot;nueve&quot; naranjas ## [1] &quot;nueve&quot; Veamos que pasa si quisieramos sumar manzanas y naranjas Error in manzanas + naranjas : non-numeric argument to binary operator Nos arroja error porque los datos almacenados en estas variables son de distinto tipo. R maneja distintos tipos de datos, los mas basicos son: Numeric: Valores con decimales (ej. 5.8) Integer: Valores enteros (ej. 4). Los integers tambien son numerics. Para especificarlos como integer debemos cerrar con una letra L (ej. 4L) Logical: Booleanos (TRUE o FALSE). Character o string: Valores de texto (ej. seis manzanas) Creemos variables de distintos tipos: mi_numeric &lt;- 6.666 mi_integer &lt;- 7L mi_logical &lt;- TRUE mi_string &lt;- &quot;tres&quot; Para chequear el tipo de datos almacenados en las variables usamos la funcion class(). class(mi_numeric) ## [1] &quot;numeric&quot; class(mi_integer) ## [1] &quot;integer&quot; class(mi_logical) ## [1] &quot;logical&quot; class(mi_string) ## [1] &quot;character&quot; 1.5 Vectores Los vectores son formaciones o arrays unidimensionales que contienen datos numericos, de caracteres o logicos, siendo todos Los elementos del mismo tipo. En R se crean vectores con la funcion de combinacion c(). Los elementos del vector se ponen dentro de c() separados por comas. Veamos un ejemplo. Un estudiante quiere analizar los datos de sus calificaciones de matematicas y lenguaje, que aparecen en la siguiente tabla: Matematicas Lenguaje Marzo 6.1 5.3 Abril 5.5 3.6 Mayo 4.4 2.0 Junio 3.8 5.5 Julio 7.0 6.5 Lo primero que hace tras recibir sus notas es generar con ellas dos vectores en R, a los que llama mate y leng, y despues los imprime. mate &lt;- c(6.1,5.5,4.4,3.8,7.0) leng &lt;- c(5.3,3.6,2.0,5.5,6.5) mate ## [1] 6.1 5.5 4.4 3.8 7.0 leng ## [1] 5.3 3.6 2.0 5.5 6.5 El estudiante no quiere confundirse. Sabe que tuvo una evaluacion al mes, pero asi como estan sus vectores, es dificil identificar a cual mes corresponden. El estudiante decide ponerle nombre a los datos almacenados en los vectores. Para nombrar elementos en R, utilizamos la funcion names(). La funcion names necesita otro vector que contenga los nombres que se quieren asignar al objeto. Siguiendo con el ejemplo: names(leng) &lt;- c(&quot;marzo&quot;,&quot;abril&quot;,&quot;mayo&quot;,&quot;junio&quot;,&quot;julio&quot;) leng ## marzo abril mayo junio julio ## 5.3 3.6 2.0 5.5 6.5 Para no tener que tipear el vector cada vez, podemos reutilizarlo si lo asignamos previamente a una variable. meses &lt;- c(&quot;marzo&quot;,&quot;abril&quot;,&quot;mayo&quot;,&quot;junio&quot;,&quot;julio&quot;) Los datos de caracter de esta variable serviran como nombres a los vectores mate y leng. names(mate) &lt;- meses names(leng) &lt;- meses mate ## marzo abril mayo junio julio ## 6.1 5.5 4.4 3.8 7.0 leng ## marzo abril mayo junio julio ## 5.3 3.6 2.0 5.5 6.5 1.5.1 Aritmetica en vectores Con ambos vectores con nombre, el estudiante quiere visualizar en que meses tuvo peores calificaciones. Se le ocurre sumar sus calificaciones por mes y dividirlas por dos para sacar un promedio mensual: suma_mes &lt;- mate + leng media_mes &lt;- suma_mes/2 media_mes ## marzo abril mayo junio julio ## 5.70 4.55 3.20 4.65 6.75 Claramente mayo no fue un buen mes. El estudiante quiere saber si le fue mejor en lenguaje o en matematicas y decide calcular un promedio simple. Para lograrlo, usa la funcion sum() para sumar los elementos de cada vector y luego divide por 5 para promediar. sum_leng &lt;- sum(leng) sum_mate &lt;- sum(mate) media_leng &lt;- sum_leng/5 media_mate &lt;- sum_mate/5 media_leng ## [1] 4.58 media_mate ## [1] 5.36 Despues se da cuenta que podria haber usado la funcion mean() para hacer lo mismo: mean_leng &lt;- mean(leng) mean_mate &lt;- mean(mate) mean_leng ## [1] 4.58 mean_mate ## [1] 5.36 1.5.2 Seleccion en vectores Para seleccionar elementos en un vector utilizamos los parentesis cuadrados [], indicando entre ellos el elemento que queremos seleccionar. Por ejemplo, queremos elegir el primer elemento del vector leng. leng[1] ## marzo ## 5.3 Como leng es un vector con nombres, tambien podemos usar el nombre asignado a los elementos. leng[&quot;marzo&quot;] ## marzo ## 5.3 Para seleccionar multiples elementos de un vector, indicamos un vector con sus indices entre parentesis. Seleccionemos el elemento 1 y el elemento 5 del vector mate. mate[c(1,5)] ## marzo julio ## 6.1 7.0 Especificar cada uno de los elementos puede ser inconveniente en algunas ocasiones. Supongamos que queremos seleccionar los tres elementos intermedios del vector mate, esto es los elementos 2, 3 y 4. Podemos usar el vector de seleccion c(2,3,4) o usar abreviadamente el vector c(2:4) que se refiere a todos los numeros naturales de 2 a 4. mate[c(2:4)] ## abril mayo junio ## 5.5 4.4 3.8 Tambien podriamos usar sus nombres. mate[c(&quot;abril&quot;,&quot;mayo&quot;,&quot;junio&quot;)] ## abril mayo junio ## 5.5 4.4 3.8 Otra forma de seleccion es la seleccion por comparacion, usando operadores logicos. Los operadores logicos tambien pueden ser usados en vectores. Como anticipamos en los ejemplos de la primera seccion, estos operadores evaluan si la expresion que indicamos es verdadera o falsa para cada elemento en el vector. Revisemos en cuales de las evaluaciones de lenguaje el estudiante califico con una nota menor a 4.0. leng&lt;4.0 ## marzo abril mayo junio julio ## FALSE TRUE TRUE FALSE FALSE Creemos dos vectores de seleccion para las calificaciones en las que el estudiante obtuvo una nota mayor o igual a 4.0, asignandolas a las variables aprueba_mate y aprueba_leng y las imprimimos. aprueba_mate &lt;- mate &gt;= 4.0 aprueba_mate ## marzo abril mayo junio julio ## TRUE TRUE TRUE FALSE TRUE aprueba_leng &lt;- leng &gt;= 4.0 aprueba_leng ## marzo abril mayo junio julio ## TRUE FALSE FALSE TRUE TRUE Usamos estos vectores de seleccion usando los parentesis cerrados. R interpreta los vectores logicos seleccionando solo los elementos que se corresponden a un TRUE en el vector de seleccion. Seleccionemos e imprimamos en cada caso dichas calificaciones. mate[aprueba_mate] ## marzo abril mayo julio ## 6.1 5.5 4.4 7.0 leng[aprueba_leng] ## marzo junio julio ## 5.3 5.5 6.5 Podemos ahorrarnos el paso intermedio de la asignacion del vector de seleccion. mate[mate &gt;= 4.0] ## marzo abril mayo julio ## 6.1 5.5 4.4 7.0 leng[leng &gt;= 4.0] ## marzo junio julio ## 5.3 5.5 6.5 1.6 Matrices En R una matriz es un conjunto de elementos del mismo tipo (numeric, character o logical) ordenados en un numero fijo de filas y columnas. Podemos construir una matriz usando la funcion matrix(). Como ejemplo, construyamos una matriz con los elementos de un vector numerico que contenga los numeros del 1 al 12 de manera tal que tenga 3 filas y 4 columnas: matrix(1:12, byrow = TRUE, nrow = 3) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 El primer argumento de la funcion se refiere a los datos o elementos que R va a ordenar en la matriz. El argumento byrow = TRUE le indica a R que llene la matriz siguiendo las filas. Si quisieramos que llene siguiendo las columnas, especificamos byrow = FALSE. Las funciones en R tienen argumentos que vienen definidos por defecto, es decir, si no los especificamos toman un valor establecido por el mismo programa. Se recomienda revisar los archivos de ayuda de las funciones antes de usarlas. ?matrix En el caso de la funcion matrix() el argumento byrow toma por default el valor FALSE. En otras palabras, si no indicamos byrow = TRUE, la matriz se llenara automaticamente siguiendo las columnas. matrix(1:12, nrow = 3) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 Finalmente tercer elemento, nrow = 3, indica cuantas filas deberia tener la matriz, en este caso 3. Tambien podemos especificar el numero de columnas, en este caso ncol = 4. Volvamos a nuestra matriz inicial. matrix(1:12, byrow = TRUE, ncol = 4) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 Si no establecemos cuantas columnas o filas queremos, R interpreta que necesitamos una matriz con una sola columna, independiente del argumento de byrow. matrix(1:12, byrow = TRUE) ## [,1] ## [1,] 1 ## [2,] 2 ## [3,] 3 ## [4,] 4 ## [5,] 5 ## [6,] 6 ## [7,] 7 ## [8,] 8 ## [9,] 9 ## [10,] 10 ## [11,] 11 ## [12,] 12 matrix(1:12, byrow = FALSE) ## [,1] ## [1,] 1 ## [2,] 2 ## [3,] 3 ## [4,] 4 ## [5,] 5 ## [6,] 6 ## [7,] 7 ## [8,] 8 ## [9,] 9 ## [10,] 10 ## [11,] 11 ## [12,] 12 Veamos un ejemplo de analisis de matrices. El Señor de los Anillos es la triologia filmica mas exitosa de la historia del cine en termino de recaudaciones a nivel mundial. La siguiente tabla muestra la recaudacion de cada una de las peliculas de la triologia, en Estados Unidos y Canada y en el resto del mundo. U.S. and Canada Otros territorios The Fellowship of the Ring $315,544,750 $572,389,161 The Two Towers $342,551,365 $608,676,051 The Return of the King $377,845,905 $764,425,193 Vamos a construir una matriz con esta informacion. Los siguientes tres vectores tienen la recaudacion de cada pelicula en millones: the_fellowship_of_the_ring &lt;- c(315.545,572.389) the_two_towers &lt;- c(342.551,608.676) the_return_of_the_king &lt;- c(377.846,764.425) Combinemos estos vectores en uno llamado recaudacion. recaudacion &lt;- c(the_fellowship_of_the_ring, the_two_towers, the_return_of_the_king) recaudacion ## [1] 315.545 572.389 342.551 608.676 377.846 764.425 Con este vector, construimos una matriz de 3 filas que llamaremos lotr y la imprimimos. lotr &lt;- matrix(recaudacion, byrow = TRUE, nrow = 3) lotr ## [,1] [,2] ## [1,] 315.545 572.389 ## [2,] 342.551 608.676 ## [3,] 377.846 764.425 Para identificar la informacion que la matriz contiene, le asignaremos nombres a las filas y las columnas de la matriz. Los siguientes vectores contienen dichos nombres: region &lt;- c(&quot;USA y Canada&quot;, &quot;Otras regiones&quot;) titulo &lt;- c(&quot;The Fellowship of the Ring&quot;, &quot;The Two Towers&quot;, &quot;The Return of the King&quot;) Usamos las funciones colnames() y rownames() para asignar los nombres e imprimimos la matriz. region -&gt; colnames(lotr) titulo -&gt; rownames(lotr) lotr ## USA y Canada Otras regiones ## The Fellowship of the Ring 315.545 572.389 ## The Two Towers 342.551 608.676 ## The Return of the King 377.846 764.425 Calculemos la recaudacion mundial de cada una de las peliculas. Para hacerlo, tenemos que sumar la recaudacion de ambas regiones. En R, la funcion rowSums() calcula los totales por fila, creando un vector con esta informacion. Asignemos este nuevo vector a la variable recaudacion_mundial y lo imprimimos. recaudacion_mundial &lt;- rowSums(lotr) recaudacion_mundial ## The Fellowship of the Ring The Two Towers ## 887.934 951.227 ## The Return of the King ## 1142.271 Agreguemos este vector a la matriz. Para hacerlo, usamos la funcion cbind(), que sirve para pegar matrices y/o vectores como columnas. Asignamos la matriz resultante a la variable lotr_mundial. Renombramos la nueva columna como \"Todo el mundo\" e imprimimos. lotr_mundial &lt;- cbind(lotr,&quot;Todo el mundo&quot;=recaudacion_mundial) lotr_mundial ## USA y Canada Otras regiones Todo el mundo ## The Fellowship of the Ring 315.545 572.389 887.934 ## The Two Towers 342.551 608.676 951.227 ## The Return of the King 377.846 764.425 1142.271 La siguiente tabla contiene informacion de la recaudacion de la triologia de El Hobbit, que fue un exito comercial aunque tenga una recepcion critica mixta. U.S. and Canada Otros territorios Todo el mundo An Unexpected Journey $303,003,568 $718,100,000 $1,021,103,568 The Desolation of Smaug $258,366,855 $700,000,000 $958,366,855 The Battle of the Five Armies $255,119,788 $700,900,000 $956,019,788 A continuacion creamos una matriz de la recaudacion en millones. Nos saltamos algunos pasos, asi que revisemos argumento por argumento. El primero es un vector que tiene los millones recaudados. Con nrow = 3 especificamos que la matriz tiene 3 filas y con byrow = TRUE que la matriz sera llenada fila a fila. Con dimnames indicamos los nombres que tendran las dimensiones de la matriz. El imput de dimnames es una lista (las revisaremos luego) que contiene dos vectores: el primer vector tiene los nombres de las filas y el segundo vector los nombres de las columnas. Imprimimos la nueva matriz para verificar que todo este en orden. the_hobbit &lt;- matrix(c(303.004,718.100,1021.104, 258.367,700.000,958.367, 255.120,700.900,956.020), nrow = 3, byrow = TRUE, dimnames = list(c(&quot;An Unexpected Journey&quot;, &quot;The Desolation of Smaug&quot;, &quot;The Battle of the Five Armies&quot;), c(&quot;USA y Canada&quot;, &quot;Otras regiones&quot;, &quot;Todo el mundo&quot;))) the_hobbit ## USA y Canada Otras regiones Todo el mundo ## An Unexpected Journey 303.004 718.1 1021.104 ## The Desolation of Smaug 258.367 700.0 958.367 ## The Battle of the Five Armies 255.120 700.9 956.020 Creemos una matriz que contenga todas las peliculas de la franquicia de Tolkien. Para hacerlo, usamos la funcion rbind() que permite pegar matrices y/o vectores en la dimension de las filas. Usamos esta funcion para pegar las matrices lotr_mundial y the_hobbit, asignamos el resultado a la variable tolkien y lo imprimimos. tolkien &lt;- rbind(lotr_mundial,the_hobbit) tolkien ## USA y Canada Otras regiones Todo el mundo ## The Fellowship of the Ring 315.545 572.389 887.934 ## The Two Towers 342.551 608.676 951.227 ## The Return of the King 377.846 764.425 1142.271 ## An Unexpected Journey 303.004 718.100 1021.104 ## The Desolation of Smaug 258.367 700.000 958.367 ## The Battle of the Five Armies 255.120 700.900 956.020 Calculemos el total de la recaudacion de las peliculas de Tolkien, por region y en todo el mundo. Usamos la funcion colSums() que calcula los totales por columna. Guardamos el resultado en tolkien_total_rev. tolkien_total_rev &lt;- rbind(tolkien,Total=colSums(tolkien)) tolkien_total_rev ## USA y Canada Otras regiones Todo el mundo ## The Fellowship of the Ring 315.545 572.389 887.934 ## The Two Towers 342.551 608.676 951.227 ## The Return of the King 377.846 764.425 1142.271 ## An Unexpected Journey 303.004 718.100 1021.104 ## The Desolation of Smaug 258.367 700.000 958.367 ## The Battle of the Five Armies 255.120 700.900 956.020 ## Total 1852.433 4064.490 5916.923 1.6.1 Seleccion en matrices La seleccion en matrices tambien utiliza parentesis cuadrado []. A diferencia de los vectores, las matrices son objetos en dos dimensiones, por lo que necesitamos especificar las filas y las columnas que queremos seleccionar. Por ejemplo, tenemos una matriz que contiene los numeros del 1 al 12 ordenados en 3 filas. mi_matriz &lt;- matrix(1:12, byrow = T, nrow = 3) mi_matriz ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 El objeto a la izquierda de la coma se refiere a las filas y el objeto a la derecha de la coma se refiere a las columnas. mi_matriz[2,3] selecciona los elementos que estan en la segunda fila y en la tercera columna. mi_matriz[2,3] ## [1] 7 Tambien podemos seleccional varias filas o columnas a la vez. mi_matriz[1:3,2:4] selecciona los elementos que estan en las filas del 1 al 3 y en las columnas del 2 al 4. mi_matriz[1:3,2:4] ## [,1] [,2] [,3] ## [1,] 2 3 4 ## [2,] 6 7 8 ## [3,] 10 11 12 Si tenemos que seleccionar todos los elementos de una fila o columna, no necesitamos especificar los objetos de las columnas o filas, respectivamente. mi_matriz[,1] selecciona todos los elementos que estan en la primera columna. mi_matriz[,1] ## [1] 1 5 9 mi_matriz[1,] selecciona todos los elementos que estan en la primera fila. mi_matriz[1,] ## [1] 1 2 3 4 Volvamos a nuestra matriz tolkien. tolkien ## USA y Canada Otras regiones Todo el mundo ## The Fellowship of the Ring 315.545 572.389 887.934 ## The Two Towers 342.551 608.676 951.227 ## The Return of the King 377.846 764.425 1142.271 ## An Unexpected Journey 303.004 718.100 1021.104 ## The Desolation of Smaug 258.367 700.000 958.367 ## The Battle of the Five Armies 255.120 700.900 956.020 Vamos a seleccionar la recaudacion de las peliculas de la triologia del Señor de los Anillos en las regiones fuera de USA y Canada y las vamos a asignar a la variable lotr_otras_regiones, e imprimimos. lotr_otras_regiones &lt;- tolkien[1:3,2] lotr_otras_regiones ## The Fellowship of the Ring The Two Towers ## 572.389 608.676 ## The Return of the King ## 764.425 1.6.2 Aritmetica en matrices Calculemos el total de recaudacion y el promedio de recaudacion de estas peliculas fuera de Estados Unidos y Canada, usando las funciones sum() y mean(). sum(lotr_otras_regiones) ## [1] 1945.49 mean(lotr_otras_regiones) ## [1] 648.4967 Esto no es diferente a lo que realizamos en la seccion vectores, porque nuestra seleccion de elementos de la matriz tolkien es un vector. Si quisieramos mantenerlo en formato matriz, usamos la funcion as.matrix(). En este caso obtenemos una matriz de 3x1. as.matrix(tolkien[1:3,2]) ## [,1] ## The Fellowship of the Ring 572.389 ## The Two Towers 608.676 ## The Return of the King 764.425 R permite que usemos los operadores matematicos elemento a elemento cuando los aplicamos a una matriz. Por ejemplo, mi_matriz * 2 multiplica cada elemento en mi_matriz por 2. mi_matriz ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 mi_matriz*2 ## [,1] [,2] [,3] [,4] ## [1,] 2 4 6 8 ## [2,] 10 12 14 16 ## [3,] 18 20 22 24 Supongamos que queremos calcular el numero de visitantes para las peliculas de Tolkien usando una estimacion del precio de la entrada al cine de $5. Dividimos la matriz tolkien por 5, para obtener el numero de visitantes en millones. tolkien/5 ## USA y Canada Otras regiones Todo el mundo ## The Fellowship of the Ring 63.1090 114.4778 177.5868 ## The Two Towers 68.5102 121.7352 190.2454 ## The Return of the King 75.5692 152.8850 228.4542 ## An Unexpected Journey 60.6008 143.6200 204.2208 ## The Desolation of Smaug 51.6734 140.0000 191.6734 ## The Battle of the Five Armies 51.0240 140.1800 191.2040 Un amigo le indica que su calculo esta errado, porque los precios de los tickets para el Señor de los Anillos (2001 al 2003) fueron menores a los precios de los tickets para El Hobbit (2012 al 2014). Sugiere que usemos la informacion de la siguiente tabla, que contiene los precios promedio de la entrada al cine para la region de USA y Canada por año de lanzamiento para cada una de las entregas de ambas triologias. LotR The Hobbit I 5.66 7.96 II 5.81 8.13 III 6.03 8.17 Pongamos en practica lo que hemos visto hasta ahora. Primero vamos a construir una matriz de 3 filas y 2 columnas que se asemeje a la tabla que nos han facilitado. USC_tickets &lt;- matrix(c(5.66,5.81,6.03, 7.96,8.13,8.17), ncol = 2, byrow = FALSE) USC_tickets ## [,1] [,2] ## [1,] 5.66 7.96 ## [2,] 5.81 8.13 ## [3,] 6.03 8.17 Ahora construimos una matriz con la recaudacion para la region de USA y Canada que siga el formato de la tabla que nos entregaron. Lo haremos paso a paso. Primero, necesitamos seleccionar de la matriz tolkien los elementos que correspondan a la region para las peliculas de el Señor de los Anillos, que iran en la columna 1, y los elementos que correspondan a dicha region para las peliculas de El Hobbit, que iran en la columna 2. Asignamos nuestras selecciones a dos vectores USC_lotr y USC_hobbit USC_lotr &lt;- tolkien[1:3,1] USC_hobbit &lt;- tolkien[4:6,1] Luego usamos la funcion cbind() para pegar nuestros vectores en una matriz. USC_tolkien &lt;- cbind(USC_lotr,USC_hobbit) Le damos nombres a las dimensiones de la matriz USC_tolkien y la imprimimos. c(&quot;LotR&quot;,&quot;The Hobbit&quot;) -&gt; colnames(USC_tolkien) c(&quot;I&quot;,&quot;II&quot;,&quot;III&quot;) -&gt; rownames(USC_tolkien) USC_tolkien ## LotR The Hobbit ## I 315.545 303.004 ## II 342.551 258.367 ## III 377.846 255.120 Finalmente, calculamos la cantidad de visitantes en millones usando la informacion que recibimos. Al igual que lo hicimos antes, dividimos los datos de recaudacion por el precio de las entradas. Esta vez se trata de dos matrices USC_tolkien y USC_tickets. Asignamos el resultado a visitantes e imprimimos. visitantes &lt;- USC_tolkien/USC_tickets visitantes ## LotR The Hobbit ## I 55.75000 38.06583 ## II 58.95886 31.77946 ## III 62.66103 31.22644 Calculemos el promedio de visitantes para cada triologia. mean(visitantes[,&quot;LotR&quot;]) ## [1] 59.1233 mean(visitantes[,&quot;The Hobbit&quot;]) ## [1] 33.69058 1.7 Factores Los factores son un tipo de dato estadistico para almacenar variables categoricas, es decir, variables con un numero limitado de categorias. Esta diferencia es importante porque R reconoce automaticamente que los factores son variables categoricas, lo que determina el tipo de analisis estadistico que pueden realizarse con ellas. Un ejemplo clasico de variable categorica es el sexo. Algunos limitan el numero de categorias de sexo a hombre y mujer. Podemos discutir que existen mas variaciones genotipicas, fenotipicas, culturales, historicas que compliquen la asignacion de estas categorias, pero convengamos que se trata de un numero x de categorias y no un numero infinito de valores numericos. Creemos un factor que contenga el autorreporte de 5 personas a las que se les pregunto cual era su sexo. La informacion esta contenida en el vector vector_sexo a continuacion. Ejecutemos el codigo para crear vector_sexo. vector_sexo &lt;- c(&quot;M&quot;,&quot;H&quot;,&quot;M&quot;,&quot;H&quot;,&quot;M&quot;) vector_sexo ## [1] &quot;M&quot; &quot;H&quot; &quot;M&quot; &quot;H&quot; &quot;M&quot; En este vector se observan dos valores: \"M\" que representa a la categoria mujer y \"H\" que representa a la categoria hombre. En terminos de R, estas categorias son factor levels. La funcion factor() codifica los vectores como factores. Creemos un factor a partir de vector_sexo, asignemoslo a factor_sexo e imprimimos. factor_sexo &lt;- factor(vector_sexo) factor_sexo ## [1] M H M H M ## Levels: H M Recordemos brevemente los tipos de variables categoricas: variables nominales y variables ordinales. Las variables nominales no tienen un orden implicito, no es posible ordenarlas en grado o valor. En contraste, las variables ordinales tienen un orden natural entre sus categorias, aunque la distancia entre estas no se conozca. No sabemos cual es la diferencia en magnitud entre alto y medio o entre medio y bajo, pero sabemos que el orden de menor a mayor es bajo, medio y alto. 1.7.1 Factores no ordenados Cuando recibimos datos, frecuentemente notamos que contienen variables categoricas con niveles especificos asociados. A veces vamos a querer cambiar el nombre de estos niveles para clarificar lo que significan. R permite hacerlo con la funcion levels(). Volvamos a nuestro factor_sexo. Este factor fue creado a partir de datos de un vector crudo vector_sexo que provenia de una encuesta en la que se codificaron las categorias como M y F para simplificar el proceso. Revisemos los niveles del factor_sexo. levels(factor_sexo) ## [1] &quot;H&quot; &quot;M&quot; Cuando creamos un factor sin especificar el orden de los factores, como acabamos de hacer con factor_sexo, R conserva como factor levels las categorias unicas presentes en el vector y les asigna un orden alfabetico. Por eso, pese a que en nuestro caso el primer elemento en el factor es M, los factor levels son H y M. Cambiemos los niveles del factor a \"Hombre\" y \"Mujer\", teniendo en cuenta este orden alfabetico. Luego comprobamos volviendo a ejecutar levels(). levels(factor_sexo) &lt;- c(&quot;Hombre&quot;, &quot;Mujer&quot;) levels(factor_sexo) ## [1] &quot;Hombre&quot; &quot;Mujer&quot; Exploremos nuestro factor_sexo. En R, la funcion summary() nos entrega una vista rapida de lo que contiene una variable. Los resultados de la funcion summary() dependen de la clase de su argumento. Veamos la diferencia al ejecutar summary() con vector_sexo y factor_sexo. summary(vector_sexo) ## Length Class Mode ## 5 character character Cuando corremos summary() con un vector, obtenemos la cantidad de elementos que almacena, la clase de datos que contiene y su modo de almacenamiento. En este caso tiene 5 elementos de clase y modo de almacenamiento character. summary(factor_sexo) ## Hombre Mujer ## 2 3 Cuando corremos summary() con un factor, obtenemos las frecuencias de cada nivel. En este caso, 2 hombres y 3 mujeres. Veamos que pasa cuando intentamos comparar los elementos de factor_sexo. Veamos los dos primeros elementos: factor_sexo[1] ## [1] Mujer ## Levels: Hombre Mujer factor_sexo[2] ## [1] Hombre ## Levels: Hombre Mujer Es \"Mujer\" mayor que \"Hombre\" ? factor_sexo[1] &gt; factor_sexo[2] ## Warning in Ops.factor(factor_sexo[1], factor_sexo[2]): &#39;&gt;&#39; not meaningful for ## factors ## [1] NA Por defecto, R devuelve NA (not available) porque la comparacion no tiene sentido, dado que se trata de una variable nominal y las categorias en factor_sexo no estan ordenadas. R le otorga un valor equivalente a los niveles de estos factores. Pero este no es siempre el caso. Como veremos a continuacion, a veces tenemos factores que poseen un orden natural entre sus categorias. 1.7.2 Factores ordenados Supongamos que nos piden crear un factor con informacion de una carrera de relevos. Basada en la velocidad de los corredores, la estrategia mas generalmente aceptada para un equipo de cuatro corredores es la siguiente: segundo mas rapido, tercero mas rapido, el mas lento, el mas rapido (ancla). Creemos un vector con esta estrategia. vector_velocidad &lt;- c(&quot;segundo mas rapido&quot;, &quot;tercero mas rapido&quot;, &quot;mas lento&quot;, &quot;mas rapido&quot;) Las categorias del vector_velocidad si tienen un orden y deberian ser convertidas a un factor ordenado. Como ya vimos, por defecto, la funcion factor() transforma los vectores en un factor no ordenado. Para crear un factor ordenado, debemos especificar dos argumentos adicionales: ordered, que acepta un argumento logico que debe ser TRUE para indicar que el factor es ordenado, y levels que acepta un vector con las categorias ordenadas. Creemos el factor_velocidad considerando las velocidades. factor_velocidad &lt;- factor(vector_velocidad, ordered = TRUE, levels = c(&quot;mas lento&quot;, &quot;tercero mas rapido&quot;, &quot;segundo mas rapido&quot;, &quot;mas rapido&quot;)) Como podemos ver, R ahora muestra que los niveles tienen un orden y los imprime de menor a mayor. En este caso no es muy ilustrativo, porque tenemos un corredor por velocidad, pero si ejecutamos summary() obtenemos las frecuencias, tal y como vimos con anterioridad. summary(factor_velocidad) ## mas lento tercero mas rapido segundo mas rapido mas rapido ## 1 1 1 1 Veamos que pasa cuando comparamos las categorias de nuestros corredores. factor_velocidad ## [1] segundo mas rapido tercero mas rapido mas lento mas rapido ## 4 Levels: mas lento &lt; tercero mas rapido &lt; ... &lt; mas rapido Es el primer corredor mas rapido que el segundo corredor? factor_velocidad[1] &gt; factor_velocidad[2] ## [1] TRUE Es el tercer corredor mas rapido que el cuarto corredor? factor_velocidad[3] &gt; factor_velocidad[4] ## [1] FALSE 1.8 Dataframes Al igual que las matrices, los data frames son objetos que tienen dos dimensiones. Sabemos que las matrices son configuraciones de datos del mismo tipo. Los datos que vimos en los ejemplos de las peliculas de Tolkien eran exclusivamente numericos. Esta limitacion no se apega a los datos que frecuente tendremos que analizar. Por ejemplo, las encuestas contienen preguntas como: Cual es su fecha de nacimiento? (variable de intervalo) Cual es su edad? (variable de razon) Cual es su estado civil? (variable nominal) Casado(a) Conviviente o pareja sin acuerdo de union civil Conviviente civil (con acuerdo de union civil) Anulado(a) Separado(a) Divorciado (a) Viudo(a) Soltero(a) Que tan de acuerdo esta con? (variable ordinal) Muy en desacuerdo Algo en desacuerdo Ni de acuerdo ni en desacuerdo Algo de acuerdo Muy de acuerdo Tiene contrato de trabajo? (variable nominal, dummy) Si No Las bases de datos que reunen todo esto contienen distintos tipos de variables que, ademas, pueden ser codificadas de diferentes formas. En R, todo esto se traduce en distintos tipos de datos numeric, character o logical. Un data frame es un objeto bidimensional en el que cada columnas puede contener un tipo de datos distinto, pero todos los datos dentro de una columna son del mismo tipo. En un data frame las columnas representan variables de un conjunto de datos y las filas representan observaciones. Como ejemplo, carguemos mtcars un data frame built-in en R. mtcars ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 ## Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 ## Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 ## Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 ## Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 ## Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 ## Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 ## AMC Javelin 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 ## Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 ## Pontiac Firebird 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 ## Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 mtcars son datos extraidos de la revista Motor Trend US de 1974, y and contiene el consumo de combustible y otros aspectos de diseño y performance para 32 modelos de automoviles. Podemos ver que las variables (mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear y carb) estan en las columnas y que los automoviles (32) en las filas. Por lo general trabajaremos con data frames mas grandes que mtcars, que no podremos mirar de un vistazo. En esos casos es necesario revisar su estructura y principales elementos antes de empezar a analizarlos. Podemos empezar mirando una pequeña parte de los datos. En R, usamos la funcion head() para imprimir las primeras observaciones de un data frame. Similarmente, la funcion tail() imprime las ultimas observaciones en el data frame. Estas funciones imprimen, ademas, una primera fila llamada header que contiene los nombres de las variables. Por default, ambas funciones muestran 5 filas. head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 tail(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.7 0 1 5 2 ## Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 ## Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 ## Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 ## Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 ## Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 Otro metodo para conocer rapidamente los datos es usar la funcion str(), que muestra la estructura del data frame. str(mtcars) ## &#39;data.frame&#39;: 32 obs. of 11 variables: ## $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... ## $ disp: num 160 160 108 258 360 ... ## $ hp : num 110 110 93 110 175 105 245 62 95 123 ... ## $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... ## $ wt : num 2.62 2.88 2.32 3.21 3.44 ... ## $ qsec: num 16.5 17 18.6 19.4 17 ... ## $ vs : num 0 0 1 1 0 1 0 1 1 1 ... ## $ am : num 1 1 1 0 0 0 0 0 0 0 ... ## $ gear: num 4 4 4 3 3 3 3 4 4 4 ... ## $ carb: num 4 4 1 1 2 1 4 2 2 4 ... Obtenemos: El numero total de observaciones (ej. 32 tipos de automoviles) El numero total de variables (ej. 11 caracteristicas de los automoviles) Una lista con todos los nombres de las variables (ej. mpg, cyl ) Los tipos de datos de cada variable (ej. num) Las primeras observaciones Ejecutar str() es sumamente informativo y deberia ser la primera tarea a realizar al recibir un data set nuevo. Podemos obtener parte de esta informacion dependiendo de lo que requisieramos. Por ejemplo, si solo quisieramos conocer las dimensiones de un data frame, usamos la funcion dim(). dim(mtcars) ## [1] 32 11 Si solo queremos conocer los nombres de las variables de un data frame, usamos names(). names(mtcars) ## [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; ## [11] &quot;carb&quot; 1.8.1 Creacion de un data frame Para practicar, crearemos un pequeño data set que describa las principales caracteristicas de 8 planetas del sistema solar. Las caracteristicas son: El tipo de planeta (Terrestres o gigantes gaseosos). El diametro del planeta relativo al diametro de la Tierra. La rotacion del planeta en relacion con la rotacion de la Tierra. Si el planeta tiene anillos (TRUE o FALSE). Estas caracteristicas estan contenidas en los siguientes vectores. Ejecutemos el codigo para asignarlos. planeta &lt;- c(&quot;Mercurio&quot;, &quot;Venus&quot;, &quot;Tierra&quot;, &quot;Marte&quot;, &quot;Jupiter&quot;, &quot;Saturno&quot;, &quot;Urano&quot;, &quot;Neptuno&quot;) tipo &lt;- c(&quot;Terrestre&quot;,&quot;Terrestre&quot;,&quot;Terrestre&quot;,&quot;Terrestre&quot;,&quot;Gigante Gaseoso&quot;,&quot;Gigante Gaseoso&quot;,&quot;Gigante Gaseoso&quot;,&quot;Gigante Gaseoso&quot;) diametro &lt;- c(0.382, 0.949, 1, 0.532, 11.209, 9.449, 4.007, 3.883) rotacion &lt;- c(58.64, -243.02, 1, 1.03, 0.41, 0.43, -0.72, 0.67) anillos &lt;- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE) Para formar nuestro data frame usamos la funcion data.frame(). Pasemos los vectores nombre, tipo, diametro, rotacion y anillos en ese orden. Asignemos el resultado a planetas_df e imprimimos. planetas_df &lt;- data.frame(planeta, tipo, diametro, rotacion, anillos) planetas_df ## planeta tipo diametro rotacion anillos ## 1 Mercurio Terrestre 0.382 58.64 FALSE ## 2 Venus Terrestre 0.949 -243.02 FALSE ## 3 Tierra Terrestre 1.000 1.00 FALSE ## 4 Marte Terrestre 0.532 1.03 FALSE ## 5 Jupiter Gigante Gaseoso 11.209 0.41 TRUE ## 6 Saturno Gigante Gaseoso 9.449 0.43 TRUE ## 7 Urano Gigante Gaseoso 4.007 -0.72 TRUE ## 8 Neptuno Gigante Gaseoso 3.883 0.67 TRUE Usemos la funcion str() para chequear la estructura de planetas_df. str(planetas_df) ## &#39;data.frame&#39;: 8 obs. of 5 variables: ## $ planeta : chr &quot;Mercurio&quot; &quot;Venus&quot; &quot;Tierra&quot; &quot;Marte&quot; ... ## $ tipo : chr &quot;Terrestre&quot; &quot;Terrestre&quot; &quot;Terrestre&quot; &quot;Terrestre&quot; ... ## $ diametro: num 0.382 0.949 1 0.532 11.209 ... ## $ rotacion: num 58.64 -243.02 1 1.03 0.41 ... ## $ anillos : logi FALSE FALSE FALSE FALSE TRUE TRUE ... 1.8.2 Seleccion en data frames Similar a la seleccion en matrices, podemos seleccionar elementos de un data frame usando los parentesis cuadrados. Recordemos que usando una coma, identificamos lo que esta a la derecha de esta como filas y lo que esta a la izquierda, como columnas. Por ejemplo, seleccionemos el diametro de Mercurio en planetas_df. planetas_df[1,3] ## [1] 0.382 Seleccionemos todos los datos que corresponden a Marte. planetas_df[4,] ## planeta tipo diametro rotacion anillos ## 4 Marte Terrestre 0.532 1.03 FALSE En vez de usar indices numericos, tambien podemos usar el nombre de las variables para seleccionar columnas de un data frame. Supongamos que queremos seleccionar los tres primeros elementos de la columna tipo. Podemos hacerlo asi: planetas_df[1:3,2] ## [1] &quot;Terrestre&quot; &quot;Terrestre&quot; &quot;Terrestre&quot; Pero una desventaja es que necesitamos saber el numero de la columna, lo que se complica si tenemos muchas variables o si en algun momento cambiamos el orden de las variables. Para solucionarlo, podemos especificar: planetas_df[1:3,&quot;tipo&quot;] ## [1] &quot;Terrestre&quot; &quot;Terrestre&quot; &quot;Terrestre&quot; A veces queremos seleccionar una columna completa. Por ejemplo, la variable anillos, a la que podemos acceder usando los parentesis cuadrados: planetas_df[,&quot;anillos&quot;] ## [1] FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE O tambien usando el signo $. A la izquierda de $ especificamos el nombre del data frame y a la derecha el nombre de la variable. Asignemos el resultado a vector_anillos e imprimimos. vector_anillos &lt;- planetas_df$anillos vector_anillos ## [1] FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE Podemos ver que las cuatro primeras observaciones no tienen anillos y las ultimas cuatro tienen anillos. Podemos usar este vector para seleccionar la informacion de los planetas que tienen anillos, porque es un vector logico. Insertamos vector_anillos a la izquierda de la coma, entre parentesis cuadrados. planetas_df[vector_anillos,] ## planeta tipo diametro rotacion anillos ## 5 Jupiter Gigante Gaseoso 11.209 0.41 TRUE ## 6 Saturno Gigante Gaseoso 9.449 0.43 TRUE ## 7 Urano Gigante Gaseoso 4.007 -0.72 TRUE ## 8 Neptuno Gigante Gaseoso 3.883 0.67 TRUE El resultado es el mismo si especificamos lo siguiente: planetas_df[anillos==TRUE,] ## planeta tipo diametro rotacion anillos ## 5 Jupiter Gigante Gaseoso 11.209 0.41 TRUE ## 6 Saturno Gigante Gaseoso 9.449 0.43 TRUE ## 7 Urano Gigante Gaseoso 4.007 -0.72 TRUE ## 8 Neptuno Gigante Gaseoso 3.883 0.67 TRUE Otra forma de seleccionar es utilizar la funcion subset(). Como su nombre lo indica, la funcion subset() selecciona un subset de datos de un data frame, el primer argumento, de acuerdo a una condicion, su segundo argumento. Seleccionemos un subset de datos que contenga aquellos planetas que tienen un diametro menor a 1 (aquellos que son mas pequeños que la Tierra). subset(planetas_df, subset = diametro&lt;1) ## planeta tipo diametro rotacion anillos ## 1 Mercurio Terrestre 0.382 58.64 FALSE ## 2 Venus Terrestre 0.949 -243.02 FALSE ## 4 Marte Terrestre 0.532 1.03 FALSE Tambien podemos seleccionar respecto a condiciones que involucren mas de una variable. Por ejemplo, seleccionemos aquellos planetas mas grandes que la Tierra que tienen una rotacion axial negativa respecto a la de Tierra. subset(planetas_df, subset = (diametro&gt;1)&amp;(rotacion&lt;0)) ## planeta tipo diametro rotacion anillos ## 7 Urano Gigante Gaseoso 4.007 -0.72 TRUE 1.8.3 Sorting Podemos ordenar las filas de un data frame de acuerdo a los valores de una variable. Para ello, usamos la funcion order() que entrega la posicion ranqueada de cada elemento en el objeto ingresado, en un orden ascendente o descendente. Veamos un ejemplo simple con un vector. numeros_desordenados &lt;- c(17,8,30) order(numeros_desordenados) ## [1] 2 1 3 Al ingresar el vector numeros_desordenados en la funcion order() obtenemos que 17, el primer elemento en numeros_desordenados, es el segundo menor; 8 es el menor; 30 es el mayor. Podemos usar esta funcion para ordenar numeros_desordenados de manera ascendente (por default) o descendente. numeros_desordenados[order(numeros_desordenados)] ## [1] 8 17 30 numeros_desordenados[order(numeros_desordenados, decreasing = TRUE)] ## [1] 30 17 8 Ordenemos los planetas de nuestro data frame planetas_df del mas chico al mas grande. Usamos order() y, como input, especificamos la variable diametro con $. Imprimimos los resultados. planetas_df[order(planetas_df$diametro),] ## planeta tipo diametro rotacion anillos ## 1 Mercurio Terrestre 0.382 58.64 FALSE ## 4 Marte Terrestre 0.532 1.03 FALSE ## 2 Venus Terrestre 0.949 -243.02 FALSE ## 3 Tierra Terrestre 1.000 1.00 FALSE ## 8 Neptuno Gigante Gaseoso 3.883 0.67 TRUE ## 7 Urano Gigante Gaseoso 4.007 -0.72 TRUE ## 6 Saturno Gigante Gaseoso 9.449 0.43 TRUE ## 5 Jupiter Gigante Gaseoso 11.209 0.41 TRUE 1.9 Listas Una lista es un objeto que contiene otros objetos, sean matrices, vectores, data frames u otras listas. Las listas no requieren que los objetos sean de un mismo tipo, tamaño, ni que contengan el mismo tipo de datos o esten relacionados entre ellos de ninguna manera. Funcionan como una carpeta donde ponemos distintos objetos para organizarlos bajo un mismo nombre y pueden almacenar practicamente cualquier pieza de informacion en ellas. Veamos un ejemplo. Los siguientes objetos contienen distintas piezas de informacion relacionada con la pelicula 2001: A Space Odyssey. Ejecutemos el codigo para crearlos. nom &lt;- c(&quot;2001: A Space Odyssey&quot;) dir &lt;- c(&quot;Stanley Kubrick&quot;) escr &lt;- c(&quot;Stanley Kubrick&quot;, &quot;Arthur C. Clarke&quot;) cred &lt;- matrix(c(&quot;Dr. Dave Bowman&quot;, &quot;Keir Dullea&quot;, &quot;Dr. Frank Poole&quot;, &quot;Gary Lockwood&quot;, &quot;Dr. Heywood R. Floyd&quot;, &quot;William Sylvester&quot;, &quot;Moon-Watcher&quot;, &quot;Daniel Richter&quot;, &quot;Dr. Andrei Smyslov&quot;, &quot;Leonard Rossiter&quot;, &quot;Elena&quot;, &quot;Margaret Tyzack&quot;, &quot;Dr. Ralph Halvorsen&quot;, &quot;Robert Beatty&quot;, &quot;Dr. Bill Michaels&quot;, &quot;Sean Sullivan&quot;, &quot;HAL 9000&quot;, &quot;Douglas Rain&quot;, &quot;Mission Controller&quot;,&quot;Frank Miller&quot;), ncol = 2, byrow = TRUE, dimnames = list(c(1:10), c(&quot;Personajes&quot;, &quot;Elenco&quot;))) IMDB &lt;- data.frame(puntaje=c(10,10,7,10,10,1,9), usuario=c(&quot;Wesley-Wang&quot;,&quot;simon_booth&quot;, &quot;suws1&quot;,&quot;Manthorpe&quot;, &quot;mmt02&quot;,&quot;Nessy_Gliana&quot;, &quot;Nazi_Fighter_David&quot;), comentario=c(&quot;Legendary&quot;, &quot;Unmatched accomplishment&quot;, &quot;Ahead of its time but...&quot;, &quot;A film of monolithic proportions&quot;, &quot;Greatest Movie of All Time&quot;,&quot;Don&#39;t believe the hype-&quot;, &quot;The final landing scene is the very hallmark of cinematic genius...&quot;)) Creemos una lista que contenga todo estos objetos. Para no confundirnos, asignamos nombres a cada objeto. Imprimimos el resultado. space_odyssey &lt;- list(titulo=nom, director=dir, escritores=escr, creditos=cred, reviews=IMDB) space_odyssey ## $titulo ## [1] &quot;2001: A Space Odyssey&quot; ## ## $director ## [1] &quot;Stanley Kubrick&quot; ## ## $escritores ## [1] &quot;Stanley Kubrick&quot; &quot;Arthur C. Clarke&quot; ## ## $creditos ## Personajes Elenco ## 1 &quot;Dr. Dave Bowman&quot; &quot;Keir Dullea&quot; ## 2 &quot;Dr. Frank Poole&quot; &quot;Gary Lockwood&quot; ## 3 &quot;Dr. Heywood R. Floyd&quot; &quot;William Sylvester&quot; ## 4 &quot;Moon-Watcher&quot; &quot;Daniel Richter&quot; ## 5 &quot;Dr. Andrei Smyslov&quot; &quot;Leonard Rossiter&quot; ## 6 &quot;Elena&quot; &quot;Margaret Tyzack&quot; ## 7 &quot;Dr. Ralph Halvorsen&quot; &quot;Robert Beatty&quot; ## 8 &quot;Dr. Bill Michaels&quot; &quot;Sean Sullivan&quot; ## 9 &quot;HAL 9000&quot; &quot;Douglas Rain&quot; ## 10 &quot;Mission Controller&quot; &quot;Frank Miller&quot; ## ## $reviews ## puntaje usuario ## 1 10 Wesley-Wang ## 2 10 simon_booth ## 3 7 suws1 ## 4 10 Manthorpe ## 5 10 mmt02 ## 6 1 Nessy_Gliana ## 7 9 Nazi_Fighter_David ## comentario ## 1 Legendary ## 2 Unmatched accomplishment ## 3 Ahead of its time but... ## 4 A film of monolithic proportions ## 5 Greatest Movie of All Time ## 6 Don&#39;t believe the hype- ## 7 The final landing scene is the very hallmark of cinematic genius... 1.9.1 Seleccion en listas Las listas estan compuestas de componentes y elementos. Los componentes son los objetos que ingresamos en la lista (vectores, matrices, data frames, otras listas) y los elementos son valores u objetos que se encuentran dentro de dichos componentes. Para seleccionar componentes usamos parentesis cuadrados dobles y dentro de ellos, el indice del componente o su nombre. Por ejemplo, seleccionamos el cuarto componente en space_odyssey. space_odyssey[[4]] ## Personajes Elenco ## 1 &quot;Dr. Dave Bowman&quot; &quot;Keir Dullea&quot; ## 2 &quot;Dr. Frank Poole&quot; &quot;Gary Lockwood&quot; ## 3 &quot;Dr. Heywood R. Floyd&quot; &quot;William Sylvester&quot; ## 4 &quot;Moon-Watcher&quot; &quot;Daniel Richter&quot; ## 5 &quot;Dr. Andrei Smyslov&quot; &quot;Leonard Rossiter&quot; ## 6 &quot;Elena&quot; &quot;Margaret Tyzack&quot; ## 7 &quot;Dr. Ralph Halvorsen&quot; &quot;Robert Beatty&quot; ## 8 &quot;Dr. Bill Michaels&quot; &quot;Sean Sullivan&quot; ## 9 &quot;HAL 9000&quot; &quot;Douglas Rain&quot; ## 10 &quot;Mission Controller&quot; &quot;Frank Miller&quot; Supongamos que queremos seleccionar las criticas de IMDB y no conocemos su indice, pero si sabemos el nombre del componente es reviews. space_odyssey[[&quot;reviews&quot;]] ## puntaje usuario ## 1 10 Wesley-Wang ## 2 10 simon_booth ## 3 7 suws1 ## 4 10 Manthorpe ## 5 10 mmt02 ## 6 1 Nessy_Gliana ## 7 9 Nazi_Fighter_David ## comentario ## 1 Legendary ## 2 Unmatched accomplishment ## 3 Ahead of its time but... ## 4 A film of monolithic proportions ## 5 Greatest Movie of All Time ## 6 Don&#39;t believe the hype- ## 7 The final landing scene is the very hallmark of cinematic genius... Podemos hacer lo mismo usando el operador $. Seleccionemos el componente escritores. space_odyssey$escritores ## [1] &quot;Stanley Kubrick&quot; &quot;Arthur C. Clarke&quot; Tambien podemos seleccionar elementos dentro de los componentes. Lo hacemos agregando a la seleccion de componente una seleccion con parentesis cuadrados simples. Recordemos que el tipo de seleccion dependera de si se trata de un componente unidimensional o bidimensional. Por ejemplo, seleccionemos a los 5 primeros actores mencionados en los creditos y sus roles. Como $creditos es una matriz, la seleccion dentro de la matriz debe ser [1:5,]. space_odyssey[[&quot;creditos&quot;]][1:5,] ## Personajes Elenco ## 1 &quot;Dr. Dave Bowman&quot; &quot;Keir Dullea&quot; ## 2 &quot;Dr. Frank Poole&quot; &quot;Gary Lockwood&quot; ## 3 &quot;Dr. Heywood R. Floyd&quot; &quot;William Sylvester&quot; ## 4 &quot;Moon-Watcher&quot; &quot;Daniel Richter&quot; ## 5 &quot;Dr. Andrei Smyslov&quot; &quot;Leonard Rossiter&quot; Cuando el componente es un data frame, podemos usar el operador $. Esto no es valido para otros tipos de componentes porque este operador no funciona con vectores atomicos. space_odyssey$reviews$comentario ## [1] &quot;Legendary&quot; ## [2] &quot;Unmatched accomplishment&quot; ## [3] &quot;Ahead of its time but...&quot; ## [4] &quot;A film of monolithic proportions&quot; ## [5] &quot;Greatest Movie of All Time&quot; ## [6] &quot;Don&#39;t believe the hype-&quot; ## [7] &quot;The final landing scene is the very hallmark of cinematic genius...&quot; Finalmente, podemos seleccionar elementos y operar con ellos directamente. Calculemos el puntaje promedio entregado por la seleccion de usuarios de IMDB que estan en reviews. mean(space_odyssey$reviews$puntaje) ## [1] 8.142857 "],["references.html", "References", " References "]]
